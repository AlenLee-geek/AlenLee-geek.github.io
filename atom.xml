<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AlenLee&#39;s blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://AlenLee-geek.github.io.git/"/>
  <updated>2018-05-08T07:12:42.946Z</updated>
  <id>https://AlenLee-geek.github.io.git/</id>
  
  <author>
    <name>AlenLee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS模块化</title>
    <link href="https://AlenLee-geek.github.io.git/2018/05/08/JS%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>https://AlenLee-geek.github.io.git/2018/05/08/JS模块化/</id>
    <published>2018-05-08T06:03:59.000Z</published>
    <updated>2018-05-08T07:12:42.946Z</updated>
    
    <content type="html"><![CDATA[<p>随着web page进化到web application,浏览器端的处理的逻辑越来越复杂，展现的样式和动画越来越多，对于工程的要求也就越来越高。于是模块化的需求也就产生了。模块化的意义：<br>   组件的复用，降低开发成本和维护成本<br>   组件单独开发，方便分工合作<br>   模块化遵循标准，方便自动化依赖管理，代码优化，部署。<br>AMD和CMD分别是requireJS和seaJS定义的标准，使用纯原生的ES5语法意味着只能使用闭包，书写和阅读都很怪异。值得一提的是AngularJS也使用类似的方式，以至于Angular的作者们都受不了，决定在AngularJS2使用新的语言AtScript，AMD长得啥样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">define([&apos;./a&apos;,&apos;./b&apos;],function(a，b)&#123;</span><br><span class="line">  ...</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p><p>CommonJS是Node.js使用的模块化标准。Node.js对于前端开发者来说不仅仅可以提供一个Server,还是一个完美的开发平台，在Node上使用Grunt/gulp构建web项目是件很爽的事情。Node的模块化声明的方式与Closure类似，只是更进一步，天然隔离了命名空间，上面的代码如果使用CommoneJS的模块化规范可以这么写：<br>  module.exports = {…}<br>  var a = require(‘./foo/bar’)<br>  browserify让使用CommonJS模块规范的代码可以运行在客户端上。<br>2.静态加载与动态加载<br>  在看ES6之前我们先看模块加载的两中方式：<br>  静态加载：在编译阶段进行，把所有需要的依赖打包到一个文件中<br>  动态加载：在运行时加载依赖</p><p>AMD标准是动态加载的代表，而CommonJS是静态加载的代表。AMD的目的是用在浏览器上，所以是异步加载的。而NodeJS是运行在服务器上的，同步加载的方式显然更容易被人接收，所以使用了CommonJS。同样的道理，如果静态加载，那就使用同步的方式，如果动态加载就必须用异步的加载方式。<br>那么ES6采用何种加载机制？<br>  ES6寄希望用简单的声明方式来完成静态加载，又不愿放弃冬天加载的特性，而这两种方式几乎不可能建档的同时现<br>  ，所以ES6提供了两种独立的模块加载方法。<br>2.1 声明的方式<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;foo&#125; from modulel</span><br></pre></td></tr></table></figure></p><p>2.2 通过System.import API的方式<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.import(&apos;some_module&apos;).then(some_module =&gt;&#123;</span><br><span class="line">  // Use some_module</span><br><span class="line">  &#125;).catch(error =&gt;&#123;</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure></p><p>export的语法，与CommonJS很像，只不过没有了module这个对象，而是直接到调用export。可以exportr如何一个函数、变量、对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export function abc()&#123;&#125;//export 一个命名的function</span><br><span class="line">export default function()&#123;&#125; //export default function</span><br><span class="line">export num = 123 //export 一个数值</span><br><span class="line">export obj = &#123;&#125;</span><br><span class="line">export &#123; obj as default &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import expt from &apos;expt&apos;//default export</span><br><span class="line">import &#123; default as myModule &#125; from &apos;expt&apos; // rename</span><br><span class="line">import &#123; abc,num,obj &#125; from &apos;expt&apos;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着web page进化到web application,浏览器端的处理的逻辑越来越复杂，展现的样式和动画越来越多，对于工程的要求也就越来越高。于是模块化的需求也就产生了。模块化的意义：&lt;br&gt;   组件的复用，降低开发成本和维护成本&lt;br&gt;   组件单独开发，方便分工合作
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Javascript Async/Await Expalained in 10 Minutes</title>
    <link href="https://AlenLee-geek.github.io.git/2018/05/07/Javascript-Async-Await-Expalained-in-10-Minutes/"/>
    <id>https://AlenLee-geek.github.io.git/2018/05/07/Javascript-Async-Await-Expalained-in-10-Minutes/</id>
    <published>2018-05-07T02:04:15.000Z</published>
    <updated>2018-05-07T02:04:15.478Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>http&amp;https</title>
    <link href="https://AlenLee-geek.github.io.git/2018/05/04/http-https/"/>
    <id>https://AlenLee-geek.github.io.git/2018/05/04/http-https/</id>
    <published>2018-05-04T05:50:36.000Z</published>
    <updated>2018-05-07T02:04:46.521Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>跟大流的小程序</title>
    <link href="https://AlenLee-geek.github.io.git/2018/05/02/%E8%B7%9F%E5%A4%A7%E6%B5%81%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    <id>https://AlenLee-geek.github.io.git/2018/05/02/跟大流的小程序/</id>
    <published>2018-05-02T07:48:00.000Z</published>
    <updated>2018-05-02T07:48:00.658Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Web Session</title>
    <link href="https://AlenLee-geek.github.io.git/2018/04/28/Web-Session/"/>
    <id>https://AlenLee-geek.github.io.git/2018/04/28/Web-Session/</id>
    <published>2018-04-28T03:00:11.000Z</published>
    <updated>2018-05-07T02:04:44.971Z</updated>
    
    <content type="html"><![CDATA[<p>回话的概念<br>用户在网站的一组相互关联的请求和响应，就是一次回话。简而言之：<br>1、回话 = 一组访问<br>2、访问 = -次请求和响应<br>例如一个简单的nodejs HTTP程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;)</span><br><span class="line">http.createServer(function(req,res)&#123;</span><br><span class="line">  res.end(&apos;hello&apos;);</span><br><span class="line">&#125;).listen(3000)</span><br></pre></td></tr></table></figure></p><p>每个请求都会进入到此处理函数：function(req,res){res.end(‘hello’)},在此函数内获得请求，处理响应，完成后发给客户端，就是一次访问。通过浏览器的developer tools,可以看到此次回话的请求内容和响应内容。</p><p>引入回话<br>我们从一个案例开始引入回话的概念，当我们需要访问站点计数一类的功能时，我们希望用户访问此站点时：<br>1、第一次访问时，显示你的访问次数为1<br>2、此后每次访问时，访问计数加1</p><p>此种情况下，我们需要有一个地方存储当前计数，这样才能在同一个客户在此访问时，可以取出当前计数，加一后返回给客户。当然也因此需要识别此用户(浏览器)。为每个用户单独计数，就是说，不同的用户访问时，需要去取对应用户的当前计数。<br>识别客户的问题，常用的方法就是使用cookie,cookie是HTTP协议的一部分。HTTP可以通过字段Set-cookie为来访问客户做一个标记，这个标记常常就是一个ID，下一次访问此站点时，HTTP会通过cookie头字段，发送此ID到站点，由此站点知道此客户的身份和这个身份关联的状态信息，比如当前访问计数，或者此身份当前的购物车的内容等等。<br>识别了客户后，就可以在web服务器内，为此客户端建立它的独特的转态信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;回话的概念&lt;br&gt;用户在网站的一组相互关联的请求和响应，就是一次回话。简而言之：&lt;br&gt;1、回话 = 一组访问&lt;br&gt;2、访问 = -次请求和响应&lt;br&gt;例如一个简单的nodejs HTTP程序&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tab
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>IOCP模型与EPOLL模型的比较</title>
    <link href="https://AlenLee-geek.github.io.git/2018/04/24/IOCP%E6%A8%A1%E5%9E%8B%E4%B8%8EEPOLL%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <id>https://AlenLee-geek.github.io.git/2018/04/24/IOCP模型与EPOLL模型的比较/</id>
    <published>2018-04-24T07:46:06.000Z</published>
    <updated>2018-05-07T02:04:43.197Z</updated>
    
    <content type="html"><![CDATA[<p>一、IOCP和Epoll之间的异同。<br>不同：<br>1、IOCP是WINDOWS系统下使用。Epoll是linux系统下使用。<br>2、IOCP是IO操作完毕之后，通过Get函数获得一个完成的事件通知。<br>Epoll是当你希望进行一个IO操作时，向Epoll查询是否可读或者可写，若处于可读或者可写转态后，Epoll会通过epoll_wait进行通知。<br>3、IOCP封装了异步的消息的通知机制，同时封装了部分IO操作。但Epoll仅仅封装了一个异步事件的通知机制，并不负责IO读写操作，Epoll保持了事件通知和IO操作间的独立性，更加简单灵活。<br>4、基于上面的描述，我们可以知道Epoll不负责IO操作，所以它只告诉你当前可读可写了，并且将协议读写缓冲填充，由用户去读写操作，此时我们可以做出额外的许多操作。IOCP则直接将IO通道里的读写操作都做完了才通知用户，当IO通道里发生了堵塞等情况我们是无法控制的。<br>相同：<br> 1、它们都是一部的时间驱动的网络模型。<br> 2、它们都可以向底层进行了指针数据传递，当返回事件时，除可通知事件类型外，还可以通知时间相关数据。<br>二、描述一下IOCP：<br>   传统服务器的网络IO流程如下：<br>   接到一个客户端连接-&gt;创建一个线程负责这个连接的IO操作-&gt;持续对新线程进行数据处理-&gt;全部数据处理完毕-&gt;终止线程。<br>   将存在的问题：<br>   1、每个链接创建一个线程，将导致过多的线程。<br>   2、维护线程所消耗的堆栈内存过大。<br>   3、操作系统创建和销毁线程过大。<br>   4、线程之间切换的上下文代价过大。<br>   此时我们可以考虑使用线程池解决其中3和4的问题。这种传统的服务器网络结构称之为回话模型。后来我们为了防止大量线程的维护，创建了I/O模型，它被希望要求可以：<br>   1、客户端状态的分离，之前会话模式我么可以通过线程状态得知客户端状态。<br>   2、允许一个客户端在不同时间被多个线程服务。<br>   这样做的话，我们的线程则会大幅度减少，这就要求以下两点：<br>   1、客户端状态的分离，之前回话模式我们可以通过线程状态得知客户端状态，但现在客户端状态要通过其他方式获取。<br>   2、I/O请求的分离，一个线程不再服务于一个客户端回话，则要求客户端对这个线程提交I/O处理请求。<br>   那么就产生了这样的一个模式，分为两部分：<br>   1：会话状态管理模块。它负责接收到一个客户端连接，就创建一个回话状态。<br>   2：当回话状态发生改变，例如断掉连接，接收到网络消息，就发送一个I/O请求给I/O工作模块进行处理。<br>   3：I/O工作模块接收到一个I/O请求后，从线程池里唤醒一个工作线程，让该工作线程处理这个I/O请求，处理完毕后，该工作线程继续挂起。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、IOCP和Epoll之间的异同。&lt;br&gt;不同：&lt;br&gt;1、IOCP是WINDOWS系统下使用。Epoll是linux系统下使用。&lt;br&gt;2、IOCP是IO操作完毕之后，通过Get函数获得一个完成的事件通知。&lt;br&gt;Epoll是当你希望进行一个IO操作时，向Epoll查询
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="https://AlenLee-geek.github.io.git/2018/04/23/webpack/"/>
    <id>https://AlenLee-geek.github.io.git/2018/04/23/webpack/</id>
    <published>2018-04-23T08:13:08.000Z</published>
    <updated>2018-05-07T02:04:40.883Z</updated>
    
    <content type="html"><![CDATA[<p>入口（entry):<br>  入口起点指示webpack应该使用哪个模块，来作为构建内部依赖图，进入入口起点后，webpack会找出有哪些模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack会找出有哪些模块和库是入口起点(直接和间接)依赖的。每个依赖项随机被处理，最后输出到称之为bundles的文件中，我们将在下一章详细讨论这个过程。<br>  可以通过在webpack配置中配置entry属性，来指定一个入口起点（或多个入口起点）。<br>出口（output)<br>output属性告诉webpack在哪里输出它所创建的bundles,以及如何命名这些文件，默认值为./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。<br>loader<br>  loader让webpack能够处理那些处理非javascript文件(webpack自身只理解javaScript)。loader可以将所有类型的文件转换为webpack能够处理的有效模块。然后你就可以利用webpack的打包能力，对他们进行处理。<br>本质上，webpack loader将所有类型的文件，转换为应用程序的依赖图（和最终的bundle)可以直接引用的模块。<br>注意：loader能够import导入任何类型的模块(例如.css文件)，这是webpack特有的功能，其他打包程序或任务执行器的可能并不支持。我们认为这种语言扩展是很有必要的。因为这可以使开发人员穿件出更准确的依赖关系图。<br>在更高层面，在webpack的配置中loader有两个目标：<br>1、test属性，用于标识出应该被对应的loader进行转换的某个或某些文件。</p><p>INSERT INTO dev_caili<code>.</code>ims_modules_bindings<code>(</code>eid<code>,</code>module<code>,</code>entry<code>,</code>call<code>,</code>title<code>,</code>do<code>,</code>state<code>,</code>direct<code>,</code>url<code>,</code>icon<code>,</code>displayorder`) VALUES (NULL, ‘we7_wmall’, ‘menu’, ‘’, ‘会员制’, ‘ptfclub-card’, ‘’, ‘0’, ‘’, ‘’, ‘100’);</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;入口（entry):&lt;br&gt;  入口起点指示webpack应该使用哪个模块，来作为构建内部依赖图，进入入口起点后，webpack会找出有哪些模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack会找出有哪些模块和库是入口起点(直接和间接)依赖的。每个依赖项随机被
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>node-demo</title>
    <link href="https://AlenLee-geek.github.io.git/2018/04/23/node-demo/"/>
    <id>https://AlenLee-geek.github.io.git/2018/04/23/node-demo/</id>
    <published>2018-04-23T02:09:12.000Z</published>
    <updated>2018-04-23T07:15:01.462Z</updated>
    
    <content type="html"><![CDATA[<p> 实现简单的静态文件的合并服务器。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">var path = require(&apos;path&apos;);</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line"></span><br><span class="line">var MIME = &#123;</span><br><span class="line">  &apos;.css&apos;:&apos;text/css&apos;,</span><br><span class="line">  &apos;.js&apos;:&apos;application/javascript&apos;</span><br><span class="line">&#125;</span><br><span class="line">function combineFiles(pathnames,callback)&#123;</span><br><span class="line">  var output = [];</span><br><span class="line">  (function next(i,len)&#123;</span><br><span class="line">    if(i&lt;len)&#123;</span><br><span class="line">      fs.readFile(pathnames[i],function(err,data)&#123;</span><br><span class="line">         if(err)&#123;</span><br><span class="line">           callback(err);</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">           output.push(data);</span><br><span class="line">           next(i + 1,len);</span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      callback(null,Buffer.concat(output));</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;)(0,pathnames.length);</span><br><span class="line">&#125;</span><br><span class="line">function main(argv)&#123;</span><br><span class="line">  var config = JSON.parse(fs.readFileSync(argv[0],&apos;utf-8&apos;));</span><br><span class="line">  var root = config.root || &apos;.&apos;;</span><br><span class="line">  var port = config.port || 80;</span><br><span class="line">  http.createServer(function(request,response)&#123;</span><br><span class="line">     var urlInfo = parseURL(root,request.url);</span><br><span class="line">     combineFiles(urlInfo.pathnames,function(err,data)&#123;</span><br><span class="line">         if(err)&#123;</span><br><span class="line">           response.writeHead(404);</span><br><span class="line">           response.end(err.message);</span><br><span class="line">         &#125;else&#123;</span><br><span class="line">           response.writeHead(200,&#123;</span><br><span class="line">             &apos;Content-type&apos;: urlInfo.mine</span><br><span class="line">           &#125;);</span><br><span class="line">           response.end(data);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">  &#125;).listen(port);</span><br><span class="line">&#125;</span><br><span class="line">function parseURL(root,url)&#123;</span><br><span class="line">  var base,pathnames,parts;</span><br><span class="line">  if(url.indexof(&apos;??&apos;) === -1)&#123;</span><br><span class="line">    url = url.replace(&apos;/&apos;,&apos;/??&apos;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  parts = url.split(&apos;??&apos;);</span><br><span class="line">  base = parts[0];</span><br><span class="line">  pathname =  parts[1].split(&apos;,&apos;).map(function(value)&#123;</span><br><span class="line">     return path.join(root,base,value);</span><br><span class="line">  &#125;);</span><br><span class="line">  return&#123;</span><br><span class="line">    mime: MIME[path.extname(pathname[0] || &apos;text/plain&apos;],</span><br><span class="line">    pathnames:pathnames</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">main(process.argv.slice(2));</span><br></pre></td></tr></table></figure></p><p> 1、使用命令行参数传递JSON配置文件路径，入口函数负责读取配置并创建服务器。<br> 2、入口函数完整描述了程序的运行逻辑，其中解析URL和合并文件的具体实现封装在其他的两个函数里。<br> 3、解析URL时先将普通URL转换为了文件合并URL，使得两种URL的处理方式可以一致。<br> 4、合并文件时使用异步API读取文件，避免服务器因等待磁盘IO而发生阻塞。<br> 我们可以把以上的保存为server.js,之后就可以通过node server.js config.json命令来启动程序。<br> 第二次迭代：<br>   1、当请求的文件比较多比较大时，串行读取文件会比较耗时，从而拉长了服务端响应等待时间。<br>   2、由于每次响应输出的数据都需要先完整地缓存在内存里，当服务器请求并发数比较大时，会有比较大的内存开销。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">functin main(argv)&#123;</span><br><span class="line">  var config = JSON.parse(fs.readFileSync(argv[0],&apos;utf-8&apos;)),</span><br><span class="line">      root = config.root || &apos;.&apos;,</span><br><span class="line">      part = config.port || 80;</span><br><span class="line">  http.creatServer(function(request,response)&#123;</span><br><span class="line">      var urlInfo = parseURL(root,request.url);</span><br><span class="line">      validateFiles(urlInfo.pathnames,function(err,pathnames)&#123;</span><br><span class="line">          if(err)&#123;</span><br><span class="line">            response.writeHead(400);</span><br><span class="line">            response.end(err.message);</span><br><span class="line">          &#125;else&#123;</span><br><span class="line">            response.writeHead(200,&#123;</span><br><span class="line">                &apos;Content-Type&apos;:urlInfo.mime</span><br><span class="line">            &#125;);</span><br><span class="line">            outputFiles(pathnames,response);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;).listent(port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function outputFiles(pathname,writer)&#123;</span><br><span class="line">  (function next(i,len)&#123;</span><br><span class="line">      if( i &lt; len )&#123;</span><br><span class="line">        var reader = fs.createReadStream(pathnames[i]);</span><br><span class="line">        reader.pipe(writer,&#123;end:false&#125;);</span><br><span class="line">        reader.on(&apos;end&apos;,function()&#123;</span><br><span class="line">            next( i+1,len);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        writer.end();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)(0,pathnames.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function validateFiles(pathnames,callback)&#123;</span><br><span class="line">  (function next(i,len)&#123;</span><br><span class="line">      if( i&lt; len)&#123;</span><br><span class="line">        fs.stat(pathnames[i],function(err,stats)&#123;</span><br><span class="line">            if(err)&#123;</span><br><span class="line">              callback(err);</span><br><span class="line">            &#125;else if(!stats.isFile())&#123;</span><br><span class="line">              callback(new Error());</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">              next(i+1,len);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        callback(null,pathnames);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)(0,pathnames.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建双守护进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var cp = require(&apos;child_process&apos;);</span><br><span class="line">var worker;</span><br><span class="line">function spawn(server,config)&#123;</span><br><span class="line">  worker = cp.spawn(&apos;node&apos;,[server,config]);</span><br><span class="line">  worker.on(&apos;exit&apos;,function(code)&#123;</span><br><span class="line">      if(code!==0)&#123;</span><br><span class="line">        spawn(server,config);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">function main(argv)&#123;</span><br><span class="line">  spawn(&apos;server.js&apos;,argv[0]);</span><br><span class="line">  process.on(&apos;SIGTERM&apos;,function()&#123;</span><br><span class="line">      worker.kill();</span><br><span class="line">      process.exit(0);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">main(process.argv.slice(2));</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt; 实现简单的静态文件的合并服务器。&lt;br&gt; &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>node-异步编程</title>
    <link href="https://AlenLee-geek.github.io.git/2018/04/20/node-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <id>https://AlenLee-geek.github.io.git/2018/04/20/node-异步编程/</id>
    <published>2018-04-20T05:53:05.000Z</published>
    <updated>2018-04-20T10:33:03.792Z</updated>
    
    <content type="html"><![CDATA[<p>NodeJs最大的特点-事件机制和异步IO。<br>回调<br>在代码中，异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步话了。但是，如果某个函数做的事情是创建一个别的线程或进程，并与JS主线程并行地做一些事情，并在事情做完后通知JS主线程，那情况又不一样了。我们接着看看以下代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function()&#123;</span><br><span class="line">  console.log(&apos;world&apos;);</span><br><span class="line">  &#125;,1000);</span><br><span class="line">  console.log(&apos;hello&apos;);</span><br></pre></td></tr></table></figure></p><p>JS本身是单线程的，无法异步执行，因此我们可以认为setTimeout这类JS规范之外的由运行环境提供的特殊函数做的事情是创建一个平行线程后立即返回，让JS主线程可以直接执行后续代码，并在收到平行进程的通知后再执行回调函数。除了setTimeout、setInterval这些常见的，这类函数还包括NodeJS提供的诸如fs.readFile之类的异步API。<br>另外，我们仍然回到JS是单线程运行的这个事实上，这决定了JS在执行完一段代码之前无法执行包括回调函数在内的别的代码。这也就是说，即使平行线程完成工作了，通知JS主线程执行回调函数了，回调函数也要等到JS主线程空闲时才能开始执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function heavyCompute(n)&#123;</span><br><span class="line">  var count = 0;</span><br><span class="line">  var i;</span><br><span class="line">  var j;</span><br><span class="line">  for( i = n; i &gt; 0; --i )&#123;</span><br><span class="line">    for( j = n; j &gt; 0; --j)&#123;</span><br><span class="line">      count += 1;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var t = new Date();</span><br><span class="line">setTimeout(function()&#123;</span><br><span class="line">  console.log(new Date() - t);</span><br><span class="line">&#125;,1000);</span><br><span class="line">heavyCompute(50000);</span><br></pre></td></tr></table></figure></p><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p>异步编程有很多特有的代码设计模式，为了实现同样的功能，使用同步方式和异步方式编写的代码会有很大差异。以下是一些常见的模式。<br>函数返回值<br>使用一个函数的输出作为另一个函数的蔬菜如是很常见的需求，在同步方式下一般按一下方式编写代码：<br>var output = fn1(fn2(‘input’));<br>而在异步方式下，由于函数执行结果不是通过返回值，而是童年过回调函数传递，因此一般按以下方式编写代码：<br>fn2(‘input’,function(output2){<br>    fn1(output2,function(output1){</p><pre><code>});</code></pre><p>})<br>遍历数组<br>在遍历数组时，使用某个函数一次对数据成员做一些出来也是常见的需求。如果函数式同步执行的，一般就会写出以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var len  = arr.length;</span><br><span class="line">var i =  0;</span><br><span class="line">for(;i &lt; len;++i)&#123;</span><br><span class="line">  arr[i] = sync(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果函数式异步执行的，以上代码就无法保证结束后所有数组成成员都处理完毕了。如果数组成员必须一个接一个串行处理，则一般按照以下方式编写异步代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">（function next(i,len,callback)&#123;</span><br><span class="line">  if( i &lt; len )&#123;</span><br><span class="line">    async(arr[i],function(value)&#123;</span><br><span class="line">        arr[i] = value;</span><br><span class="line">        next(i + 1,len, callback);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;）(o,arr.length,function()&#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p>可以看到，与异步串行遍历的版本相比，以上代码并行处理所有数组成员。并通过计数器变量来判断什么时候所有数组成员都处理完毕了。<br>异常处理<br>JS自身提供的异常捕获和处理机制–try..catch..,只能用于同步执行的的代码，以下是一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function sync(fn)&#123;</span><br><span class="line">  return fn();</span><br><span class="line">&#125;</span><br><span class="line">try&#123;</span><br><span class="line">  sync(null);</span><br><span class="line">&#125;catch(err)&#123;</span><br><span class="line">  console.log(&apos;Error:%s&apos;,err.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，异常会沿着代码执行路径一直冒泡，直到遇到第一个try语句是被捕获住，但由于异步函数会打断代码执行路径，异步函数执行过程中以及执行之后产生的异常冒泡到执行路径被打断的位置时，如果一直没有遇到try语句，就作为一个全局异常抛出。一下是一个例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function async(fn,callback)&#123;</span><br><span class="line">  setTimeout(function()&#123;</span><br><span class="line">    callback(fn());</span><br><span class="line">  &#125;,0)；</span><br><span class="line">&#125;</span><br><span class="line">try&#123;</span><br><span class="line">  async(null,fucntion(data)&#123;</span><br><span class="line"></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;catch(err)&#123;</span><br><span class="line">  console.log(&apos;Error:%s&apos;,err.message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为代码执行路径被打断了，我么就需要在异常冒泡到断电之前用try语句把异常捕获住，并通过回调函数传递被捕获的异常，于是我们可以像下边这样改造上边的例子。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function async(fn,callback)&#123;</span><br><span class="line">  setTimeount(function()&#123;</span><br><span class="line">      try&#123;</span><br><span class="line">        callback(null,fn());</span><br><span class="line">      &#125;catch&#123;</span><br><span class="line">        callback(err);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;,0);</span><br><span class="line">&#125;</span><br><span class="line">async(null,function(err,data)&#123;</span><br><span class="line">    if(err)&#123;</span><br><span class="line">      console.log(&apos;Error:%s&apos;,err.message);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>异步再次被捕获住了，在NodeJS中，几乎所有异步API都按照以上方式设计，回调函数中第一个参数都是err.因此我们在编写自己的异步函数时，也可以按照这种方式来处理异常，与NodeJS的设计风格保持一致。<br>有了异常处理方式后，</p><h4 id="域（Domain"><a href="#域（Domain" class="headerlink" title="域（Domain)"></a>域（Domain)</h4><p>NodeJS提供了domain模块，可以简化异步代码的异常处理。在介绍该模块之前，我们需要首先理解什么是“域”的概念。简单的讲，一个域就是一个JS运行环境，在一个运行环境中，如果一个异常没有被捕获，将作为一个全局异常被抛出。NodeJS通过process对象提供了捕获全局异常的方法，实例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.on(&apos;uncaughtException&apos;,function(err)&#123;</span><br><span class="line">  console.log(&apos;Error:%s&apos;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;NodeJs最大的特点-事件机制和异步IO。&lt;br&gt;回调&lt;br&gt;在代码中，异步编程的直接体现就是回调。异步编程依托于回调来实现，但不能说使用了回调后程序就异步话了。但是，如果某个函数做的事情是创建一个别的线程或进程，并与JS主线程并行地做一些事情，并在事情做完后通知JS主线
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>node-进程管理</title>
    <link href="https://AlenLee-geek.github.io.git/2018/04/19/node-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://AlenLee-geek.github.io.git/2018/04/19/node-进程管理/</id>
    <published>2018-04-19T08:18:58.000Z</published>
    <updated>2018-04-19T10:51:50.252Z</updated>
    
    <content type="html"><![CDATA[<p>进程管理<br>NodeJS可以感知和控制自身进程的运行环境和转态，也可以创建子进程并与其协同工作，这使得NodeJS可以把多个程序组合在一起完成某项工作，并在其中充当胶水和调度器的作用。</p><p>NodeJS自带的fs模块比较基础，把一个目录里的所有的所有的文件和子目录都拷贝到另一个目录里需要些不少代码。另外我们也知道，终端下的CP命令比较好用，一条cp -r source/* target命令就能搞定目录拷贝。那我们首先看看如何使用NodeJS调用终端命令来简化目录拷贝，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var child_process = require(&apos;child_process&apos;);</span><br><span class="line">var util = require(&apos;util&apos;);</span><br><span class="line">function copy(source,target,callback)&#123;</span><br><span class="line">  child_process.exec(</span><br><span class="line">    util.format(&apos;cp -r %s/* %s&apos;,source,target),callback;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line">copy(&apos;a&apos;,&apos;b&apos;,function(err)&#123;</span><br><span class="line">   //...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>从以上代码中可以看到，子进程是异步运行的，通过回调函数返回执行结果。</p><p>任何一个进程都有启动进程是使用的命令行参数，有标准输入标准输出，有运行权限，有运行环境和运行状态。在NodeJs中，可以通过process对象感知和控制NodeJS自身进程的方方面面。另外需要注意的是，process不是内置模块，而是一个全局对象。因此可以在任何地方都可以直接使用。<br>使用child_process模块可以创建和控制子进程。该模块提供的API中最核心的是.spawn.<br>cluster模块是对child_process模块的进一步封装。专用于解决单进程NodeJS web服务器无法充分利用多核CPU的问题。使用该模块可以简化多进程服务器程序的开发，让每个核上运行一个工作进程，并统一通过主进程监听端口和分发请求。<br>应用场景</p><p>获取命令行参数<br>在NodeJS中可以通过process.argv获取命令行参数，但是比较意外的是，node执行程序路径和主模块文件路径固定占据了argv[0]和argv[1]两个位置，而第一个参数命令行参数从argv[2]开始。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进程管理&lt;br&gt;NodeJS可以感知和控制自身进程的运行环境和转态，也可以创建子进程并与其协同工作，这使得NodeJS可以把多个程序组合在一起完成某项工作，并在其中充当胶水和调度器的作用。&lt;/p&gt;
&lt;p&gt;NodeJS自带的fs模块比较基础，把一个目录里的所有的所有的文件和子
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>node-网络操作</title>
    <link href="https://AlenLee-geek.github.io.git/2018/04/18/node-%E7%BD%91%E7%BB%9C%E6%93%8D%E4%BD%9C/"/>
    <id>https://AlenLee-geek.github.io.git/2018/04/18/node-网络操作/</id>
    <published>2018-04-18T08:01:46.000Z</published>
    <updated>2018-04-19T08:15:12.693Z</updated>
    
    <content type="html"><![CDATA[<p>NodeJS本来的用途是编写高性能Web服务器，使用NodeJS内置的http模块 简单实现一个HTTP服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">http.createServer(function(request,response)&#123;</span><br><span class="line">    response.writeHead(200,&#123;&apos;Content-Type&apos;:&apos;text-plain&apos;&#125;);</span><br><span class="line">    response.end(&apos;Hello world&apos;);</span><br><span class="line">&#125;).listen(3000);</span><br></pre></td></tr></table></figure></p><p>‘http’模块提供两种使用方式：<br>1.作为服务端使用时，创建一个HTTP服务器，监听HTTP客户端请求并返回响应。<br>2.作为客户端使用时，发起一个HTTP客户端请求，获取服务端响应。<br>首先我们看看服务端模式下我们如何工作。如开门红中的例子所示，首先需要使用.createServer方法创建一个服务器，然后调用.listen方法监听端口。之后，每当来了一个客户端请求，创建服务器时传入的回调函数就被调用一次。<br>HTTP请求本质上是一个数据流。由请求头（headers）和请求体（body)组成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">User-Agent: curl/7.26.0</span><br><span class="line">Host: localhost</span><br><span class="line">Accept: */*</span><br><span class="line">Content-Length: 11</span><br><span class="line">Content-Type: application/x-www-form-urlencodeed</span><br><span class="line"></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></p><p>可以看到，空行之上是请求头，之下是请求体。HTTP请求在发送给服务器时，可以认为是按照从头到尾的顺序一个字节一个字节地以数据流方式发送的。而http模块创建的HTTP服务器在接收到完整的请求头后，就会调用回调函数，在回调函数中，除了可以使用request对象访问请求头部数据外，还能把request对象当作一个只读数据流来访问请求体数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">http.createServer(function(request,response)&#123;</span><br><span class="line">    var body = [];</span><br><span class="line">    console.log(request.method);</span><br><span class="line">    console.log(request.headers);</span><br><span class="line">    request.on(&apos;data&apos;,function(chunk)&#123;</span><br><span class="line">        body.push(chunk);</span><br><span class="line">    &#125;);</span><br><span class="line">    request.on(&apos;end&apos;,function()&#123;</span><br><span class="line">        body = Buffer.concat(body);</span><br><span class="line">        console.log(body.toString());</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>处理HTTP请求时url模块使用率超高，因为该模块允许解析URL、生成URL、以及拼接URL。首先我们来看看一个完整的URL的各组成部分。<br>Zlib模块提供了数据压缩和解压的功能。当我们处理HTTP请求和响应时，可能需要用到这个模块。<br>首先我们看一个使用zlib模块压缩HTTP响应体数据的例子。这个例子中，判断了客户端是否支持gzip,并在支持的情况下使用zlib模块返回gzip之后的响应体数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var zlib = require(&apos;zlib&apos;);</span><br><span class="line">var server = http.createServer(function(request,response)&#123;</span><br><span class="line">   var i = 1024;</span><br><span class="line">   var data = &apos;&apos;;</span><br><span class="line">   while( i-- )&#123;</span><br><span class="line">     data +=&apos;&apos;;</span><br><span class="line">   &#125;</span><br><span class="line">   if((request.headers[&apos;accept-encoding&apos;] || &apos;&apos;).indexof(&apos;gzip&apos;)!== -1)&#123;</span><br><span class="line">     zlib.gzip(data,function(err,data)&#123;</span><br><span class="line">       response.writeHead(200,&#123;</span><br><span class="line">         &apos;Content-Type&apos;:&apos;text/plain&apos;,</span><br><span class="line">         &apos;Content-Encoding&apos;:&apos;gzip&apos;     </span><br><span class="line">        &#125;);</span><br><span class="line">        response.end(data);</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;else&#123;</span><br><span class="line">     response.writeHead(200,&#123;</span><br><span class="line">       &apos;content-Type&apos;:&apos;text/plain&apos;</span><br><span class="line">     &#125;);</span><br><span class="line">     response.end(data);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(9090);</span><br></pre></td></tr></table></figure></p><p>使用zlib模块解压HTTP响应体数据的例子，这个例子中，判断了服务端响应是否使用gzip,并在压缩的情况下使用zlib模块响应体数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var options = &#123;</span><br><span class="line">  hostname:&apos;www.baidu.com&apos;,</span><br><span class="line">  port:80,</span><br><span class="line">  path:&apos;/&apos;,</span><br><span class="line">  method:&apos;GET&apos;,</span><br><span class="line">  headers:&#123;</span><br><span class="line">    &apos;Accept-Encoding&apos;:&apos;gzip,deflate&apos;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">http.request(options,function(response)&#123;</span><br><span class="line">  var body = [];</span><br><span class="line">  response.on(&apos;data&apos;,function(chunck)&#123;</span><br><span class="line">      body.push(chunk);</span><br><span class="line">  &#125;);</span><br><span class="line">  response.on(&apos;end&apos;,function()&#123;</span><br><span class="line">      body = Buffer.concat( body );</span><br><span class="line">      if(response.headers[&apos;content-encoding&apos;] === &apos;gzip&apos;)&#123;</span><br><span class="line">        zlib.gunzip(body,function(err,data)&#123;</span><br><span class="line">          console.log(data.toString());</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;else&#123;</span><br><span class="line">        console.log(data.toString());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>Net<br>net模块可用于创建Socket服务器或Socket客户端。由于Socket在前端领域的使用范围还不是很广，从Socket层面来实现HTTP请求和响应。首先我们来看一个使用Socket搭建一个简约版的HTTP服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">net.createServer(function(conn)&#123;</span><br><span class="line">    conn.on(&apos;data&apos;,function(data)&#123;</span><br><span class="line">      conn.write([</span><br><span class="line">        &apos;HTTP/1.1 200 ok&apos;,</span><br><span class="line">        &apos;Content-Type: text/plain&apos;,</span><br><span class="line">        &apos;Content-Length:11&apos;,</span><br><span class="line">        &apos;&apos;,</span><br><span class="line">        &apos;Hello World&apos;</span><br><span class="line">        ].join(&apos;\n&apos;));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(80);</span><br></pre></td></tr></table></figure></p><p>使用Socket发起HTTP客户端请求的例子，这个例子中，Socket客户端在建立连接后发送了一个HTTP GET请求，并通过data事件监听函数来获取服务器响应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var options = &#123;</span><br><span class="line">  port:80,</span><br><span class="line">  host:&apos;www.baidu.com&apos;</span><br><span class="line">&#125;</span><br><span class="line">var client = net.connect(options,function()&#123;</span><br><span class="line">    client.write([</span><br><span class="line">      &apos;GET / HTTP/1.1&apos;,</span><br><span class="line">      &apos;User-Agent: curl/7.26.0&apos;,</span><br><span class="line">      &apos;Host:www.baidu.com&apos;,</span><br><span class="line">      &apos;Accept:*/*&apos;,</span><br><span class="line">      &apos;&apos;,</span><br><span class="line">      &apos;&apos;</span><br><span class="line">      ].join(&apos;\n&apos;));</span><br><span class="line">&#125;);</span><br><span class="line">client.on(&apos;data&apos;,function(data)&#123;</span><br><span class="line">  cosole.log(data.toString());</span><br><span class="line">  client.end();</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;NodeJS本来的用途是编写高性能Web服务器，使用NodeJS内置的http模块 简单实现一个HTTP服务器。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span clas
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>node-Path</title>
    <link href="https://AlenLee-geek.github.io.git/2018/04/17/node-Path/"/>
    <id>https://AlenLee-geek.github.io.git/2018/04/17/node-Path/</id>
    <published>2018-04-17T02:28:20.000Z</published>
    <updated>2018-04-18T06:40:47.475Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>操作文件时难免不与文件路径打交道，NodeJs提供了path内置模块来简化路径相关操作，并提升代码可读性。<br>1.path.normalize<br>将传入的路径转换为标准路径，具体讲的话。除了解析路径中的.与..外，还能去掉多余的斜杠。如果还有程序需要使用路径作为某些数据的索引，但又允许用户随意输入路径时，就需要使用该方法保证路径的我唯一性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var cache = &#123;&#125;;</span><br><span class="line">function store(key,value)&#123;</span><br><span class="line">  cache[path.normallize(key)] = value;</span><br><span class="line">&#125;</span><br><span class="line">store(&apos;foo/bar&apos;,1);</span><br><span class="line">store(&apos;foo/baz//../bar&apos;,2);</span><br><span class="line">console.log(cache);</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>path.join<br>将传入的多个路径拼接为标准路径。该方法可以避免手工拼路径字符串的繁琐，并且能在不同系统下使用相应的路径的路径分隔符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.join(&apos;foo/&apos;,&apos;baz/&apos;,&apos;../bar&apos;);//=&gt;foo/bar</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>path.extname<br>当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用。以下是一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">path.extname(&apos;foo/bar.js&apos;);</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="遍历目录"><a href="#遍历目录" class="headerlink" title="遍历目录"></a>遍历目录</h4><p>遍历目录是操作文件时的一个常见需求。比如写一个程序，需要找到并处理指定目录下的所有JS文件时，就需要遍历整个目录。<br>递归算法<br>  遍历目录时一般使用递归算法，否则就难以编写出简洁的代码，递归算法与数学归纳法类似，通过不断缩小问题的规模来解决问题。以下示例说明了这种方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function factorial(n)&#123;</span><br><span class="line">  if( n === 1)&#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    return n * factorial( n - 1 );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>遍历算法<br>目录是一个树状结构，在遍历时一般使用深度优先+先序遍历算法。深度优先，意味着到达一个节点后，首先接着遍历子节点而不是邻居节点。先序遍历，意味着首次到达了某节点就算遍历完成，而不是最后一次返回某节点才算数。因此使用这种遍历方式是，下边这棵树的遍历顺序是A&gt;B&gt;D&gt;E&gt;C&gt;F<br>同步遍历<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function travel(dir,callback)&#123;</span><br><span class="line">  fs.readdirSync(dir).forEach(function(file)&#123;</span><br><span class="line">    var pathname = path.join(dir,file);</span><br><span class="line">    if( fs.statSync(pathname).isDirectory())&#123;</span><br><span class="line">      travel(pathname,callback);</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">      callback(pathname);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>异步遍历<br>如果读取目录或读取文件使用的是异步API，目录遍历函数实现起来会有些复杂，但原理完全相同，travel函数的异步版本如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function travel(dir,callback,finish)&#123;</span><br><span class="line">  fs.readdir(dir,function(err,files)&#123;</span><br><span class="line">    (function next(i)&#123;</span><br><span class="line">      if(i &lt; file.length )&#123;</span><br><span class="line">          var pathname = path.join(dir,files[i]);</span><br><span class="line">          fs.stat(pathname,function(err,stats)&#123;</span><br><span class="line">            if(stats.isDeirectory())&#123;</span><br><span class="line">              travel(pathname,callback,function()&#123;</span><br><span class="line">                next(i + 1);</span><br><span class="line">              &#125;)</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">               callback(pathname,function()&#123;&#125;)</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>文本编码<br>使用NodeJS编写前端工具时，操作的最多的文本文件，因此也就涉及到了文件编码的处理问题。我们常用的文本编码有UTF8和GBK两种，并且UTF8文件还可能带有BOM。在读取不同编码的文本文件时，需要将文件内容转换为JS使用的UTF8编码字符串后才能正常处理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;操作文件时难免不与文件路径打交道，NodeJs提供了path内置模块来简化路径相关操作，并提升代码可读性。&lt;br&gt;1.path.normalize&lt;br&gt;将传入的路径转换为标准路径，具体讲的话。除了解析路径中的.与..外，还能去掉多余的斜杠。如果还
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>File System(文件系统)</title>
    <link href="https://AlenLee-geek.github.io.git/2018/04/16/File-System-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://AlenLee-geek.github.io.git/2018/04/16/File-System-文件系统/</id>
    <published>2018-04-16T03:24:04.000Z</published>
    <updated>2018-04-17T02:26:56.444Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>NodeJS通过fs内置模块提供对文件的操作。fs模块提供的API基本上可以风味一下三类<br>. 文件属性读写<br>  其中常用的有fs.stat、fs.chmod、fs.chown等等。<br>. 文件内容读写<br>  其中常用的有fs.readFile、fs.readdir、fs.writeFile。fs.mkdir等等。<br>. 底层文件操作。<br>  其中常用的有fs.open、fs.read、fs.write、fs.close等等。</p></blockquote><p>NodeJS最为精华的异步IO模型在fs模块里有充分的体现。例如上边提到的这些API都通过回调函数传递结果。以fs.readFile为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(pathname,function(err,data)&#123;</span><br><span class="line">  if(err)&#123;</span><br><span class="line"></span><br><span class="line">  &#125;else&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;NodeJS通过fs内置模块提供对文件的操作。fs模块提供的API基本上可以风味一下三类&lt;br&gt;. 文件属性读写&lt;br&gt;  其中常用的有fs.stat、fs.chmod、fs.chown等等。&lt;br&gt;. 文件内容读写&lt;br&gt;  其中常用的有fs.r
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>node-Stream</title>
    <link href="https://AlenLee-geek.github.io.git/2018/04/15/node-Stream/"/>
    <id>https://AlenLee-geek.github.io.git/2018/04/15/node-Stream/</id>
    <published>2018-04-15T14:43:15.000Z</published>
    <updated>2018-04-15T14:53:19.078Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数据流（Stream）"><a href="#数据流（Stream）" class="headerlink" title="数据流（Stream）"></a>数据流（Stream）</h4><blockquote><p>当内存中无法一次装下需要处理的数据是，或者一边读取一边处理更加高效时，我们就需要用到数据流。NodeJS中通过各种Stream来提供对数据流的操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var rs = fs.createReadStream(pathname);</span><br><span class="line">rs.on(&apos;data&apos;,function(chunk)&#123;</span><br><span class="line">  doSomething(chunk);</span><br><span class="line">&#125;);</span><br><span class="line">rs.on(&apos;end&apos;,function()&#123;</span><br><span class="line">    cleanup();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var rs = fs.creatReadStream(src);</span><br><span class="line">rs.on(&apos;data&apos;,function(chunck)&#123;</span><br><span class="line">  rs.pause();</span><br><span class="line">  dosomething(chunck,function()&#123;</span><br><span class="line">    rs.resume();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">rs.on(&apos;end&apos;,function()&#123;</span><br><span class="line">  cleanup();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;数据流（Stream）&quot;&gt;&lt;a href=&quot;#数据流（Stream）&quot; class=&quot;headerlink&quot; title=&quot;数据流（Stream）&quot;&gt;&lt;/a&gt;数据流（Stream）&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;当内存中无法一次装下需要处理的数据是，或者
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>node-buffer</title>
    <link href="https://AlenLee-geek.github.io.git/2018/04/15/node-buffer/"/>
    <id>https://AlenLee-geek.github.io.git/2018/04/15/node-buffer/</id>
    <published>2018-04-15T14:22:16.000Z</published>
    <updated>2018-04-15T14:42:37.598Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Buffer-数据块"><a href="#Buffer-数据块" class="headerlink" title="Buffer(数据块)"></a>Buffer(数据块)</h4><blockquote><p>JS语言自身只有字符串数据类型，没有二进制数据类型，因此NodeJS提供了一个与String对等的全局构造函数Buffer来提供对二进制数据类型，除了可以读取文件得到Buffer的实例外，还能够直接构造，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var bin = new Buffer([]);//十六进制</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>Buffer与字符串类似，除了可以用.length属性得到字节长度，还可以用【index】方式读取指定位置的字节，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin[0] = 0x67</span><br></pre></td></tr></table></figure></p></blockquote><p>Buffer与字符串能够相互转化，例如可以使用指定编码将二进制数据转化为字符串：<br>var str = bin.toString(‘utf-8’);<br>或者反过来，将字符串转换为指定编码下的二进制数据<br>var bin  = new Buffer(‘hello’,’utf-8’)<br>Buffer与字符串一个重要区别。字符串是只读的，并且字符串的任何修改得到都是一个新字符串，原字符串保持不变，至于Buffer，更像是可以做指针操作的C 语言数组。<br>.slice方法也不是返回一个新的BUffer，而更像是返回了指向原Buffer中间的摸个位置的指针，</p><blockquote><p>也因此，如果想要拷贝一份Buffer,得首先创建一个新的Buffer，并通过.copy方法把原Buffer只能中的数据复制过去。这个类似于申请一块新的内存，并把已有内存中的数据复制过去。<br>总之，Buffer将JS的数据处理能力从字符串扩展到了任意二进制数据。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Buffer-数据块&quot;&gt;&lt;a href=&quot;#Buffer-数据块&quot; class=&quot;headerlink&quot; title=&quot;Buffer(数据块)&quot;&gt;&lt;/a&gt;Buffer(数据块)&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;JS语言自身只有字符串数据类型，没有二进制数据
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>文件操作</title>
    <link href="https://AlenLee-geek.github.io.git/2018/04/15/%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>https://AlenLee-geek.github.io.git/2018/04/15/文件操作/</id>
    <published>2018-04-15T08:28:56.000Z</published>
    <updated>2018-04-15T14:19:56.215Z</updated>
    
    <content type="html"><![CDATA[<h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><blockquote><p>让前端觉的获得神器的不是NodeJS能做网络编程，而是NodeJS能够操作文件，小至文件查找，大致代码编译，几乎没有一个前端工具不操作文件，几乎也只需要一些数据处理逻辑，再加上一些文件操作，就能购编写出大多数前端工具。本文将介绍预支相关的NodeJS内置模块。<br>NodeJS提供了基本的文件 操作API，但是像文件拷贝这种高级功能没有提供，因此我们先拿文件拷贝程序练手。与copy命令类似，我们的程序需要能接受源文件路径与目标文件路径两个参数。<br>小文件copy<br>我们使用NodeJS内置的fs模块简单实现这个程序如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">function copy(src,dst)&#123;</span><br><span class="line">  fs.writeFileSync(dst,fs.readFileSync(src));</span><br><span class="line">&#125;</span><br><span class="line">function main(argv)&#123;</span><br><span class="line">  copy(argv[0],argv[1]);</span><br><span class="line">&#125;</span><br><span class="line">main(process.argv.slice(2));</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>大文件拷贝<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var fs = require(&apos;fs&apos;);</span><br><span class="line">function copy(src,dst)&#123;</span><br><span class="line">  fs.createReadStream(src).pipe(fs.createWriteStream(dst));</span><br><span class="line">&#125;</span><br><span class="line">funciton main(argv)&#123;</span><br><span class="line">  copy(argv[0],argv[1]);</span><br><span class="line">&#125;</span><br><span class="line">main(process.argv.slice(2));</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;文件操作&quot;&gt;&lt;a href=&quot;#文件操作&quot; class=&quot;headerlink&quot; title=&quot;文件操作&quot;&gt;&lt;/a&gt;文件操作&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;让前端觉的获得神器的不是NodeJS能做网络编程，而是NodeJS能够操作文件，小至文件查找，大致
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>二进制模块</title>
    <link href="https://AlenLee-geek.github.io.git/2018/04/15/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A8%A1%E5%9D%97/"/>
    <id>https://AlenLee-geek.github.io.git/2018/04/15/二进制模块/</id>
    <published>2018-04-15T05:46:48.000Z</published>
    <updated>2018-04-15T08:27:07.250Z</updated>
    
    <content type="html"><![CDATA[<h4 id="二进制模块"><a href="#二进制模块" class="headerlink" title="二进制模块"></a>二进制模块</h4><blockquote><p>虽然一般我们使用JS编写模块，但NodeJS也支持使用C/C++编写二进制模块，编译好的二进制模块除了文件扩展名是.node外，和JS模块的使用方式相同。虽然二进制模块能使用操作系统提供的所有功能，拥有无限的潜能，但对于前端而言编写过于困难，并且难以夸平台使用，因此不在本教程的覆盖范围内。</p></blockquote><h4 id="代码的组织和部署"><a href="#代码的组织和部署" class="headerlink" title="代码的组织和部署"></a>代码的组织和部署</h4><blockquote><p>有经验的c程序员在编写一个新程序时首先从make文件写起。同样的，使用NodeJs编写程序前，为了有个良好的开端。首先需要准备好代码的目录结构和部署方式，就如同修房子要先搭脚手架。</p></blockquote><h4 id="模块路劲解析规则"><a href="#模块路劲解析规则" class="headerlink" title="模块路劲解析规则"></a>模块路劲解析规则</h4><blockquote><p>我们已经知道，require函数支持斜杠（/）或盘符（C:)开头的绝对路径，也支持./开头的相对路劲。但这两种路径之间奖励了强耦合关系，一旦某个模块文件的存放位置需要变更，使用该模块的其他的模块的代码也需要跟着调整，变的牵一发而动全身。因此，require函数支持第三种形式的路径，写法类似于foo/bar，并依次按照以下规则解析路径，直到找到模块位置。<br>1.内置模块<br>如果传递给require函数的是NodeJS内置模块名称，不做路径解析，直接返回模块的导出对象，例如require(‘fs’)。<br>2.node_modules目录<br>NodeJS定义了一个特殊的node_modules目录用于存放模块。例如某个模块的绝对路是/home/user/hello.js,在该模块中使用require(‘foo/bar’)方式加载模块时，则NodeJS依次尝试使用以下路径。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/home/user/node_modules/foo/bar</span><br><span class="line">/home/node_modules/foo/bar</span><br><span class="line">/node_modules/foo/bar</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>3.NODE_PATH环境变量<br>与PATH环境变量类型，NodeJS允许通过NODE_PATH环境变量来指定额外的模块搜索路径。NODE_PATH环境变量中包含已到多个目录路径，路径之间在Linux中使用：分隔，在window下使用；分隔。<br>当使用require(‘foo/bar’)的方式加载模块时，则NodeJS依次尝试一下路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NODE_PATH = /home/user/lib:/home/lib</span><br></pre></td></tr></table></figure></p></blockquote><p>当使用require(‘foo/bar’)的方式加载模块时，则NodeJS依次尝试一下路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/home/user/lib/foo/bar</span><br><span class="line">/home/lib/foo/bar</span><br></pre></td></tr></table></figure></p><h4 id="包（package"><a href="#包（package" class="headerlink" title="包（package)"></a>包（package)</h4><blockquote><p>我们已经知道了JS模块的模块基本单位是单个JS文件，但复杂些往往由多个子模块组成。为了便于管理和使用，我们可以把由多个子模块组成的大模块称为包，并把所有子模块放在同一个目录里。<br>在组成一个包的所有子模块中，需要有一个入口模块，入口模块的导出对象被称为包的导出对象。例如有以下目录结构。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- /home/user/lib</span><br><span class="line">  -cat/</span><br><span class="line">       head.js</span><br><span class="line">       body.js</span><br><span class="line">       main.js</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>其中cat目录定义了一个包，其中包含了3个子模块。main.js作为入口模块，其内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var head = require(&apos;./head&apos;);</span><br><span class="line">var body = require(&apos;./body&apos;);</span><br><span class="line">exports.create = function(name)&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    name:name,</span><br><span class="line">    head:head.create(),</span><br><span class="line">    body:body.create()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>在其他模块里使用包的时候，需要加载包的入口模块，接着上例，使用require(‘/home/user/lib/cat/main’)能达到目的，但是入口模块名称出现在路径里看上去不是个好主意。因此我们需要做点额外的工作，让包使用起来更像是单个模块。<br>index.js<br>当模块的文件名是index.js，加载模块时可以使用模块所在的目录的路径代替模块文件路径，</p></blockquote><h4 id="命令行程序"><a href="#命令行程序" class="headerlink" title="命令行程序"></a>命令行程序</h4><blockquote><p>使用NodeJS编写的东西，要么是一个包，要么是一个命令行程序，而前者最终也会用于开发后者。因此我们在部署代码时需要一些技巧，让用户觉得自己是在使用一个命令行程序。<br>例如我们用NodeJS写了个程序，可以把命令行参数原样打印出来。该程序很简单，在主模块内实现了所有功能。并且写好后，</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;二进制模块&quot;&gt;&lt;a href=&quot;#二进制模块&quot; class=&quot;headerlink&quot; title=&quot;二进制模块&quot;&gt;&lt;/a&gt;二进制模块&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;虽然一般我们使用JS编写模块，但NodeJS也支持使用C/C++编写二进制模块，编译好的二
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>node</title>
    <link href="https://AlenLee-geek.github.io.git/2018/04/14/node/"/>
    <id>https://AlenLee-geek.github.io.git/2018/04/14/node/</id>
    <published>2018-04-14T13:37:45.000Z</published>
    <updated>2018-04-14T15:00:11.733Z</updated>
    
    <content type="html"><![CDATA[<h5 id="NodeJS基础"><a href="#NodeJS基础" class="headerlink" title="NodeJS基础"></a>NodeJS基础</h5><blockquote><p>JS是脚本语言，脚本语言都是需要一个额解析器才能运行。对于写在HTML页面里面的JS，浏览器充当了解析器的角色、而对于需要独立运行的JS，NodeJS就是一个解析器。<br>每一种解析器都是一个运行环境，不但允许JS定义各种数据结构们进行各种计算，还允许JS使用运行环境提供的内置队形和方法做一些事情。例如运行在浏览器中的JS的用途是是操作DOM，浏览器就提供了document之类的内置对象。而运行在NodeJS中JS的用途是操作磁盘文件或搭建HTTP服务器，NodeJS就相应提供了fs、http等内置对象。</p></blockquote><h5 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h5><blockquote><p>尽管存在，听说可以直接运行JS文件，但多数同学在接触新东西时，首先关心的是有啥用处，以及能带来什么价值。<br>NodeJS的作者说，他创造NodeJS的目的是为了实现高性能Web服务器。他首先看重的是事件机制和异步IO模型的优越性，而不是JS。但是他需要选择一种编程语言实现他的想法，这种编程语言不能自带IO功能，并且需要能良好支持事件机制，JS没有自带IO功能，天生就用于处理浏览器中的DOM事件，并且拥有一群程序员，因此就称为了天然的选择。<br>NodeJS在服务端活跃起来，出现了大批基于NodeJS的Web服务。而另一方面，NodeJS让前端众如获神器，终于可以让自己的能力覆盖范围跳出浏览器窗口，更大批的前端工具如雨后春笋。<br>因此，对于前端而言，虽然不是人人都要拿NodeJS写一个服务器程序，但简单可至使用 命令交互模式调试JS代码片段，复杂可至编写工具提升工作效率。<br>编写稍大一点的程序时一般都会讲代码模块化。在NodeJS中，一般将代码合理拆分到不同的JS文件中，每一个文件及时一个模块，而<strong>文件路径就是模块名</strong>。<br>在编写每一个模块时，都有require、exports、module三个预先定义好的变量可以使用。</p></blockquote><h5 id="require"><a href="#require" class="headerlink" title="require"></a>require</h5><blockquote><p>require 函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可使用相对路径（以./开头），或者绝对路径（/或者C:之类的盘符开头）。另外，模块名中的.js扩展名可以省略，</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var foo1 = require(&apos;./foo&apos;);</span><br><span class="line">var foo2 = require(&apos;./foo.js&apos;);</span><br><span class="line">var foo3 = require(&apos;./home/user/foo&apos;);</span><br><span class="line">var foo4 = require(&apos;./home/user/foo.js&apos;);</span><br></pre></td></tr></table></figure><blockquote><p>另外，可以使用以下方式加载和使用一个JSON文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var data = require(&apos;./data.json&apos;);</span><br></pre></td></tr></table></figure><h4 id="exports"><a href="#exports" class="headerlink" title="exports"></a>exports</h4><blockquote><p>exports对象是当前模块导出对象，用于导出导出模块公有方法和属性，别的模块通过require函数使用当前模块时得到的就是模块exports对象，以下例子中导出的一个公有方法。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.hello = function()&#123;</span><br><span class="line">  console.log(&apos;Hello World&apos;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="module"><a href="#module" class="headerlink" title="module"></a>module</h4><blockquote><p>通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。例如模块导出对象默认是一个普通 对象。如果想改为一个函数的话，可以使用以下方式。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports = function()&#123;</span><br><span class="line">  console.log(&apos;hello world&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，模块默认导出对象被替换为一个函数。</p><h4 id="模块初始化"><a href="#模块初始化" class="headerlink" title="模块初始化"></a>模块初始化</h4><blockquote><p>一个模块中的JS代码仅在模块第一次被使用时执行一次，并在执行过程中初始化模块的导出导出对象。之后，缓存起来的导出对象呗重复利用。<br>主模块<br>通过命令行参数传入给NodeJS已启动程序的模块被称为主模块。主模块负责调度组成整个程序的其他模块完成工作，例如通过以下命令启动程序时，main.js就是主程序。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var i = 0;</span><br><span class="line">function count()&#123;</span><br><span class="line">  return ++i;</span><br><span class="line">&#125;</span><br><span class="line">exports.count = count;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var counter1 = require(&apos;./util/counter&apos;);</span><br><span class="line">var counter2 = require(&apos;./util/counter&apos;);</span><br><span class="line">console.log(counter1.count());</span><br><span class="line">console.log(counter2.count());</span><br><span class="line">console.log(counter2.count());</span><br></pre></td></tr></table></figure><blockquote><p>可以看到，counter.js并没有因为被require了两次而初始化两次。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;NodeJS基础&quot;&gt;&lt;a href=&quot;#NodeJS基础&quot; class=&quot;headerlink&quot; title=&quot;NodeJS基础&quot;&gt;&lt;/a&gt;NodeJS基础&lt;/h5&gt;&lt;blockquote&gt;
&lt;p&gt;JS是脚本语言，脚本语言都是需要一个额解析器才能运行。对于写在HT
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>List</title>
    <link href="https://AlenLee-geek.github.io.git/2018/04/11/List/"/>
    <id>https://AlenLee-geek.github.io.git/2018/04/11/List/</id>
    <published>2018-04-11T03:42:44.000Z</published>
    <updated>2018-04-14T13:38:29.185Z</updated>
    
    <content type="html"><![CDATA[<ol><li>列表的抽象数据类型定义<br>为了设计列表的抽象数据类型，需要给出列表的定义，包括列表应该拥有哪些属性，应该在列表上执行哪些操作。<br>列表是一组有序的数据，每个列表中的数据项称为元素。在JavaScript中，列表中元素可以是任意数据类型，<br>类表中可以保存多少元素并没有事先限定，实际使用时元素的数量受到程序内存的限制。</li><li>listSize保存列表中袁术的个数，可以在雷彪末尾append一个元素，也可以在一个给定元素后或列表的其实位置insert<br>一个元素，使用remove方法从列表中删除元素，使用clear方法清空列表中所有的元素。</li><li>toString()方法显示列表中所有的元素，使用getElement()方法显示当前元素。</li><li>append：给列表添加元素。</li><li>remove：从列表中删除元素。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;列表的抽象数据类型定义&lt;br&gt;为了设计列表的抽象数据类型，需要给出列表的定义，包括列表应该拥有哪些属性，应该在列表上执行哪些操作。&lt;br&gt;列表是一组有序的数据，每个列表中的数据项称为元素。在JavaScript中，列表中元素可以是任意数据类型，&lt;br&gt;类表中可以
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Array</title>
    <link href="https://AlenLee-geek.github.io.git/2018/04/11/Array/"/>
    <id>https://AlenLee-geek.github.io.git/2018/04/11/Array/</id>
    <published>2018-04-11T02:19:47.000Z</published>
    <updated>2018-04-11T04:00:51.873Z</updated>
    
    <content type="html"><![CDATA[<blockquote><h4 id="在脚本语言里很常见的一个特性是，数组中的元素不必是通哟中数据类型，这一点和衡多编程语言不同"><a href="#在脚本语言里很常见的一个特性是，数组中的元素不必是通哟中数据类型，这一点和衡多编程语言不同" class="headerlink" title="在脚本语言里很常见的一个特性是，数组中的元素不必是通哟中数据类型，这一点和衡多编程语言不同"></a>在脚本语言里很常见的一个特性是，数组中的元素不必是通哟中数据类型，这一点和衡多编程语言不同</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var objects = [1,&apos;alen&apos;,true,null];</span><br></pre></td></tr></table></figure></blockquote><blockquote><h4 id="当把一个数组赋给另外一个数组时，只是为被赋值的数组增加了一个新的引用，当你通过原引用修改了数组的值，"><a href="#当把一个数组赋给另外一个数组时，只是为被赋值的数组增加了一个新的引用，当你通过原引用修改了数组的值，" class="headerlink" title="当把一个数组赋给另外一个数组时，只是为被赋值的数组增加了一个新的引用，当你通过原引用修改了数组的值，"></a>当把一个数组赋给另外一个数组时，只是为被赋值的数组增加了一个新的引用，当你通过原引用修改了数组的值，</h4><h4 id="另外一个引用也会感知到这个变化，"><a href="#另外一个引用也会感知到这个变化，" class="headerlink" title="另外一个引用也会感知到这个变化，"></a>另外一个引用也会感知到这个变化，</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var nums = [];</span><br><span class="line">for(var i = 0;i &lt; 10;i++)&#123;</span><br><span class="line">  nums[i] =i+1;</span><br><span class="line">&#125;</span><br><span class="line">var samenums = nums;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h4 id="这种行为被称为浅复制，新数组依然指向原来的数组。"><a href="#这种行为被称为浅复制，新数组依然指向原来的数组。" class="headerlink" title="这种行为被称为浅复制，新数组依然指向原来的数组。"></a>这种行为被称为浅复制，新数组依然指向原来的数组。</h4><h4 id="使用深复制，将原来数组的每一个元素都复制一份到新数组中，可以写一个深复制函数来做这件事。"><a href="#使用深复制，将原来数组的每一个元素都复制一份到新数组中，可以写一个深复制函数来做这件事。" class="headerlink" title="使用深复制，将原来数组的每一个元素都复制一份到新数组中，可以写一个深复制函数来做这件事。"></a>使用深复制，将原来数组的每一个元素都复制一份到新数组中，可以写一个深复制函数来做这件事。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function copy(arr1,arr2)&#123;</span><br><span class="line">  for(var i = 0; i &lt; arr1.length; ++i)&#123;</span><br><span class="line">    arr2[i] = arr1[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h4 id="查找元素indexof"><a href="#查找元素indexof" class="headerlink" title="查找元素indexof(),"></a>查找元素indexof(),</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var names = [&apos;alen&apos;,&apos;jhon&apos;,&apos;Clayton&apos;];</span><br><span class="line">putstr(&apos;Enter a name to search for: &apos;);</span><br><span class="line">var name = readline();</span><br><span class="line">var position = name.indexof(name);</span><br><span class="line">if( position &gt;= 0)&#123;</span><br><span class="line">  print(&apos;Found&apos; + name + &apos; at position &apos;+ position);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">  print(name + &apos;not found in array.&apos;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><h4 id="迭代器方法"><a href="#迭代器方法" class="headerlink" title="迭代器方法"></a>迭代器方法</h4><p>最后一组方法是迭代器方法，这些方法对数组中的每个元素一个函数，可以返回一个值，一组值或者一个新数组<br>不生成新数组的迭代器方法<br>forEach(),该方法接受一个函数作为参数，对数组中的每个元素使用该函数、<br>every(),该方法接受一个返回值为布尔类型的函数，对数组中的每一个袁术使用该函数，如果对于所有的元素，该该函数均返回true.<br>some(),方法接受一个返回值为布尔类型的函数，只要有一个元素使得该函数返回true<br>reduce()方法接受一个函数，返回一个值，该方法会从一个累加值开始，不断对累加值和数组中的后续</p><h4 id="生成新数组的迭代器方法"><a href="#生成新数组的迭代器方法" class="headerlink" title="生成新数组的迭代器方法"></a>生成新数组的迭代器方法</h4><p>有两个迭代器方法可以生成新数组；map()和filter()</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;h4 id=&quot;在脚本语言里很常见的一个特性是，数组中的元素不必是通哟中数据类型，这一点和衡多编程语言不同&quot;&gt;&lt;a href=&quot;#在脚本语言里很常见的一个特性是，数组中的元素不必是通哟中数据类型，这一点和衡多编程语言不同&quot; class=&quot;headerli
      
    
    </summary>
    
    
  </entry>
  
</feed>
